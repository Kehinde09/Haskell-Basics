{-# LANGUAGE InstanceSigs #-}

import Control.Applicative
import Control.Monad
import Data.Maybe
import System.IO

-- HC19T1: Applicative Instance for Pair
data Pair a = Pair a a deriving Show

instance Functor Pair where
    fmap f (Pair x y) = Pair (f x) (f y)

instance Applicative Pair where
    pure x = Pair x x
    (Pair f g) <*> (Pair x y) = Pair (f x) (g y)

-- HC19T2: addThreeApplicative Function
addThreeApplicative :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int
addThreeApplicative mx my mz = (\x y z -> x + y + z) <$> mx <*> my <*> mz

-- HC19T3: safeProduct for Maybe Int
safeProduct :: [Maybe Int] -> Maybe Int
safeProduct = foldr (liftA2 (*)) (Just 1)

-- HC19T4: liftAndMultiply with liftA2
liftAndMultiply :: (Int -> Int -> Int) -> Maybe Int -> Maybe Int -> Maybe Int
liftAndMultiply = liftA2

-- HC19T5: applyEffects with <*>
applyEffects :: (IO Int, IO Int) -> IO Int
applyEffects (ioX, ioY) = (+) <$> ioX <*> ioY

-- HC19T6: repeatEffect with forever
repeatEffect :: IO () -> IO ()
repeatEffect = forever

-- HC19T7: conditionalPrint with when
conditionalPrint :: Bool -> String -> IO ()
conditionalPrint cond msg = when cond (putStrLn msg)

-- HC19T8: discardSecond with <*
discardSecond :: IO a -> IO b -> IO a
discardSecond = (<*)

-- HC19T9: pureAndApply Demonstration
pureAndApply :: IO ()
pureAndApply = do
    let val = pure (+1) <*> Just 5
    print val

-- HC19T10: combineResults for Either
combineResults :: Either String Int -> Either String Int -> Either String Int
combineResults = liftA2 (+)

-- HC19T11: Applicative Instance for Wrapper
data Wrapper a = Wrapper a deriving Show

instance Functor Wrapper where
    fmap f (Wrapper x) = Wrapper (f x)

instance Applicative Wrapper where
    pure = Wrapper
    (Wrapper f) <*> (Wrapper x) = Wrapper (f x)

-- HC19T12: sumThreeApplicative for Either String Int
sumThreeApplicative :: Either String Int -> Either String Int -> Either String Int -> Either String Int
sumThreeApplicative ex ey ez = (\x y z -> x + y + z) <$> ex <*> ey <*> ez

-- HC19T13: whenApplicative Function
whenApplicative :: Bool -> IO () -> IO ()
whenApplicative cond action = when cond action

-- HC19T14: replicateEffect with replicateM
replicateEffect :: Int -> IO a -> IO [a]
replicateEffect n action = replicateM n action

-- HC19T16: applyWithEffects and <*>
applyWithEffects :: IO Int -> IO Int -> IO Int
applyWithEffects io1 io2 = (+) <$> io1 <*> io2

-- HC19T17: simulateMaybeEffect for Multiple Maybe
simulateMaybeEffect :: (Int -> Int -> Int) -> Maybe Int -> Maybe Int -> Maybe Int
simulateMaybeEffect = liftA2

-- HC19T18: combineEitherResults with Multiple Either
combineEitherResults :: Either String Int -> Either String Int -> Either String Int -> Either String Int
combineEitherResults ex ey ez = (\x y z -> x + y + z) <$> ex <*> ey <*> ez

-- HC19T19: sequenceApplicative for Maybe List
sequenceApplicative :: [Maybe a] -> Maybe [a]
sequenceApplicative = sequenceA

-- HC19T20: replicateForever with forever
replicateForever :: IO () -> IO ()
replicateForever = forever

-- Example main to demonstrate some of the functions
main :: IO ()
main = do
    print $ addThreeApplicative (Just 1) (Just 2) (Just 3)
    print $ safeProduct [Just 2, Just 3, Just 4]
    print $ liftAndMultiply (*) (Just 3) (Just 5)
    sumIO <- applyEffects (return 5, return 10)
    print sumIO
    conditionalPrint True "This prints!"
    conditionalPrint False "This will NOT print"
    discardSecond (putStrLn "First") (putStrLn "Second")
    pureAndApply
    print $ combineResults (Right 5) (Right 7)
    print $ sumThreeApplicative (Right 2) (Right 3) (Right 4)
    replicateEffect 3 (putStrLn "Hello")
    print $ sequenceApplicative [Just 1, Just 2, Just 3]
